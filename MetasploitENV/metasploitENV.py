from pymetasploit3.msfrpc import MsfRpcClient
import nmap3
from gym import Env
from gym.spaces import Box, Discrete
import random
import numpy as np
import time 

def getActionList():
    client = MsfRpcClient('123', port=55552)
    f = open("MetasploitENV/listaction", "r")
    string_read = f.read()
    list_action = string_read.split('\n')
    return list_action, client

def getOSInfor(shell):
    # shell.write("uname")
    # if ("Linux" in shell.read()):
    #     return "Linux",0
    # elif ("is not recognized as an internal" in shell.read()):
    #     return "Windows",1
    return "Windows",1

def checkIfRoot(shell):
    # isroot=0
    # shell.write("whoami")
    # if ("root" in shell.read()) or ("Administrator" in shell.read()):
    #     isroot = 1
    # else:
    #     isroot = 0
    return 1

class ExpEnv(Env):
    def __init__(self, host):
        self.action_list, self.client = getActionList()
        self.is_action_use = [False for i in range(len(self.action_list))] 
        self.is_action_successed = [-1 for i in range(len(self.action_list))] 
        self.action_space = Discrete(len(self.action_list))
        self.state = [-1,-1,-1,-1]
        self.observation_space = np.array([-1,-1,-1,-1])
        self.shell = self.client.sessions.session(list(self.client.sessions.list.keys())[0])
        self.host = host
        self.os, self.osnum = getOSInfor(self.shell)
        self.isroot=checkIfRoot(self.shell)
        self.shower_length = 70
        print("Host:",self.host)
        print("OS System:",self.os)

    def step(self, action):
        self.shower_length -= 1
        reward = 0
        temp = self.action_list[action]


        if self.is_action_use[action] == False:
            res = -1
            if self.is_action_successed[action] == -1:
                res = self.ExcuteModule(temp,self.is_action_use[action])
            else:
                res = self.is_action_successed[action]
            if res == True:
                reward = 1
            else:
                reward = -10
            self.state = [self.osnum,self.isroot,res,1]
            self.is_action_successed[action]=res
            self.is_action_use[action] = True
        else:
            if self.is_action_successed[action]==True:
                reward = -5
                print("--- ",temp)
            else:
                reward = -10
                print("--- ",temp)
            self.state = [self.osnum,self.isroot,self.is_action_successed[action],1]

        if self.shower_length <= 0:
            done = True
        else:
            done = False

        info = {}
        print("===> State: ",[self.state, reward, done, info])
        print("")
        return self.state, reward, done, info
    
    def ExcuteModule(self,module,is_used):
        exploit = self.client.modules.use("post",module.replace("post/",""))
        id_session = 0
        count=0
        for ids in self.client.sessions.list:
            if count==0:
                id_session = int(ids)
                break
            count+=1
        exploit['SESSION'] = id_session
        cid = self.client.consoles.console().cid
        res=self.client.consoles.console(cid).run_module_with_output(exploit)
        # print(res)
        if ("aborted due to failure" not in res) and ("failed" not in res) and ("'uname' is not recognized as an internal or external command" not in res):
            if (self.os == "Windows" and "* incompatible session platform: windows" in res):
                print("‚ùå ", module)
                return False
            elif (self.os == "Linux" and "* incompatible session platform: linux" in res):
                print("‚ùå",module)
                return False
            elif (self.os == "Linux" and "* incompatible session platform: linux" in res and "* incompatible session platform: unix" in res):
                print("‚ùå",module)
                return False
            elif (self.os == "Linux" and "* incompatible session type: shell" in res and "* incompatible session platform: unix" in res):
                print("‚ùå",module)
                return False
            elif (self.os == "Linux" and "windows" in module):
                print("‚ùå",module)
                return False
            elif (self.os=="Windows" and "linux" in module):
                print("‚ùå",module)
                return False
            else:
                print("üî•",module)
                return True
        else:
            print("‚ùå ", module)
            return False

    def reset(self):
        self.state = [-1,-1,-1,-1]
        self.is_action_use = [False for i in range(len(self.action_list))] 
        self.shower_length = 70
        return self.state
